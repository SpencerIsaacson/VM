//fairly slow
__gradient(Color a, Color b)
{

	for (int y = 0; y < vm_height; ++y)
	{
		float t = y/(float)vm_height;
		Color col = lerp_color(a, b, t);
		for (int x = 0; x < vm_width; ++x)
			mem.frame_buffer.pixels[y*vm_width+x] = col;
	}
}

//faster
_gradient(Color a, Color b)
{

	Color col = a;
	for (int y = 0; y < vm_height; ++y)
	{
		float t = y/(float)vm_height;
		col = lerp_color(a, b, t);

		memset_u32_4wide(&mem.frame_buffer.pixels[y*vm_width], col, vm_width);
	}
}

gradient_r(Color a, Color b, int r)
{

	Color col = a;
	for (int y = 0; y < vm_height; ++y)
	{
		if(y > r){
			float t = (y-r)/(float)(vm_height-r);
			col = lerp_color(a, b, t);
		}

		memset_u32_4wide(&mem.frame_buffer.pixels[y*vm_width], col, vm_width);
	}
}

fill_unrolled_row(u64 *p, u64 value)
{
	p[0] = value;
	p[1] = value;
	p[2] = value;
	p[3] = value;
	p[4] = value;
	p[5] = value;
	p[6] = value;
	p[7] = value;
	p[8] = value;
	p[9] = value;
	p[10] = value;
	p[11] = value;
	p[12] = value;
	p[13] = value;
	p[14] = value;
	p[15] = value;
	p[16] = value;
	p[17] = value;
	p[18] = value;
	p[19] = value;
	p[20] = value;
	p[21] = value;
	p[22] = value;
	p[23] = value;
	p[24] = value;
	p[25] = value;
	p[26] = value;
	p[27] = value;
	p[28] = value;
	p[29] = value;
	p[30] = value;
	p[31] = value;
	p[32] = value;
	p[33] = value;
	p[34] = value;
	p[35] = value;
	p[36] = value;
	p[37] = value;
	p[38] = value;
	p[39] = value;
	p[40] = value;
	p[41] = value;
	p[42] = value;
	p[43] = value;
	p[44] = value;
	p[45] = value;
	p[46] = value;
	p[47] = value;
	p[48] = value;
	p[49] = value;
	p[50] = value;
	p[51] = value;
	p[52] = value;
	p[53] = value;
	p[54] = value;
	p[55] = value;
	p[56] = value;
	p[57] = value;
	p[58] = value;
	p[59] = value;
	p[60] = value;
	p[61] = value;
	p[62] = value;
	p[63] = value;
	p[64] = value;
	p[65] = value;
	p[66] = value;
	p[67] = value;
	p[68] = value;
	p[69] = value;
	p[70] = value;
	p[71] = value;
	p[72] = value;
	p[73] = value;
	p[74] = value;
	p[75] = value;
	p[76] = value;
	p[77] = value;
	p[78] = value;
	p[79] = value;
	p[80] = value;
	p[81] = value;
	p[82] = value;
	p[83] = value;
	p[84] = value;
	p[85] = value;
	p[86] = value;
	p[87] = value;
	p[88] = value;
	p[89] = value;
	p[90] = value;
	p[91] = value;
	p[92] = value;
	p[93] = value;
	p[94] = value;
	p[95] = value;
	p[96] = value;
	p[97] = value;
	p[98] = value;
	p[99] = value;
	p[100] = value;
	p[101] = value;
	p[102] = value;
	p[103] = value;
	p[104] = value;
	p[105] = value;
	p[106] = value;
	p[107] = value;
	p[108] = value;
	p[109] = value;
	p[110] = value;
	p[111] = value;
	p[112] = value;
	p[113] = value;
	p[114] = value;
	p[115] = value;
	p[116] = value;
	p[117] = value;
	p[118] = value;
	p[119] = value;
	p[120] = value;
	p[121] = value;
	p[122] = value;
	p[123] = value;
	p[124] = value;
	p[125] = value;
	p[126] = value;
	p[127] = value;
	p[128] = value;
	p[129] = value;
	p[130] = value;
	p[131] = value;
	p[132] = value;
	p[133] = value;
	p[134] = value;
	p[135] = value;
	p[136] = value;
	p[137] = value;
	p[138] = value;
	p[139] = value;
	p[140] = value;
	p[141] = value;
	p[142] = value;
	p[143] = value;
	p[144] = value;
	p[145] = value;
	p[146] = value;
	p[147] = value;
	p[148] = value;
	p[149] = value;
	p[150] = value;
	p[151] = value;
	p[152] = value;
	p[153] = value;
	p[154] = value;
	p[155] = value;
	p[156] = value;
	p[157] = value;
	p[158] = value;
	p[159] = value;
	p[160] = value;
	p[161] = value;
	p[162] = value;
	p[163] = value;
	p[164] = value;
	p[165] = value;
	p[166] = value;
	p[167] = value;
	p[168] = value;
	p[169] = value;
	p[170] = value;
	p[171] = value;
	p[172] = value;
	p[173] = value;
	p[174] = value;
	p[175] = value;
	p[176] = value;
	p[177] = value;
	p[178] = value;
	p[179] = value;
	p[180] = value;
	p[181] = value;
	p[182] = value;
	p[183] = value;
	p[184] = value;
	p[185] = value;
	p[186] = value;
	p[187] = value;
	p[188] = value;
	p[189] = value;
	p[190] = value;
	p[191] = value;
	p[192] = value;
	p[193] = value;
	p[194] = value;
	p[195] = value;
	p[196] = value;
	p[197] = value;
	p[198] = value;
	p[199] = value;
	p[200] = value;
	p[201] = value;
	p[202] = value;
	p[203] = value;
	p[204] = value;
	p[205] = value;
	p[206] = value;
	p[207] = value;
	p[208] = value;
	p[209] = value;
	p[210] = value;
	p[211] = value;
	p[212] = value;
	p[213] = value;
	p[214] = value;
	p[215] = value;
	p[216] = value;
	p[217] = value;
	p[218] = value;
	p[219] = value;
	p[220] = value;
	p[221] = value;
	p[222] = value;
	p[223] = value;
	p[224] = value;
	p[225] = value;
	p[226] = value;
	p[227] = value;
	p[228] = value;
	p[229] = value;
	p[230] = value;
	p[231] = value;
	p[232] = value;
	p[233] = value;
	p[234] = value;
	p[235] = value;
	p[236] = value;
	p[237] = value;
	p[238] = value;
	p[239] = value;
}

void mountains(int r[vm_width])
{	
	Color rock = 0xFF888888;

	for (int x = 0; x < vm_width; ++x)
	for (int y = r[x]; y < vm_height; ++y)
	{
		mem.frame_buffer.pixels[y*vm_width+x] = rock;
	}
}

#define sprite_width 32
#define sprite_height 32
typedef Color Sprite[sprite_width*sprite_height];

draw_sprite(Sprite sprite, int x, int y)
{
	for (int _x = 0; _x < sprite_width; ++_x)
	for (int _y = 0; _y < sprite_height; ++_y)
	{
		mem.frame_buffer.pixels[(y+_y)*vm_width+(x+_x)] = sprite[_y*sprite_width+_x];
	}
}

draw_sprite_t(Sprite sprite, int x, int y)
{
	for (int _x = 0; _x < sprite_width; ++_x)
	for (int _y = 0; _y < sprite_height; ++_y)
	{
		Color col = sprite[_y*sprite_width+_x];
		if(col != -1)
		mem.frame_buffer.pixels[(y+_y)*vm_width+(x+_x)] = col;
	}
}

draw_tex(Texture tex, int x, int y)
{
	for (int _x = 0; _x < tex.width; ++_x)
	for (int _y = 0; _y < tex.height; ++_y)
	{
		mem.frame_buffer.pixels[(y+_y)*vm_width+(x+_x)] = mem.RAM[tex.address+_y*tex.width+_x];
	}
}

draw_tex_t(Texture tex, int x, int y)
{
	for (int _x = 0; _x < tex.width; ++_x)
	for (int _y = 0; _y < tex.height; ++_y)
	{
		Color col =  mem.RAM[tex.address+_y*tex.width+_x];
		if(col != white)
		mem.frame_buffer.pixels[(y+_y)*vm_width+(x+_x)] = col;
	}
}

typedef struct
{
	u64 address; //"pointer" to the pixels in stronkbox's RAM
	u32 width, height;
} Texture;

draw_inline_tex_t(InlineTexture *tex, int x, int y)
{
	for (int _x = 0; _x < tex->width; ++_x)
	for (int _y = 0; _y < tex->height; ++_y)
	{
		Color col = tex->pixels[_y*tex->width+_x];
		if(col != white)
		mem.frame_buffer.pixels[(y+_y)*vm_width+(x+_x)] = tex->pixels[_y*tex->width+_x];
	}
}

typedef struct
{
	s32 whole;
	u32 fractional;
} Fixed;

bool rect_intersectb(SideRect a, SideRect b)
{
	return a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
}

typedef struct
{
	int left, right, top, bottom;
} SideRect;